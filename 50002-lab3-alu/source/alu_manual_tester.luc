module alu_manual_tester#(
    CLK_FREQ ~ 1000 : CLK_FREQ > 0) 
(
    input clk,  // clock
    input rst,  // reset
    input io_button[5],
    input io_dip[3][8],
    output io_led[3][8],
    output io_segment[8],
    output io_select[4],
    output led[8]
) {
    
    alu alu
    
    enum States {
        SET_A_LOW,
        SET_A_HIGH,
        SET_B_LOW,
        SET_B_HIGH,
        COMPUTE,
        IDLE
    }
    
    const SIZE = 32
    const SEVEN_SEG_DIV = $is_sim() ? 3 : 16 // put 6 for sim, 16 on hardware 
    const CLK_FREQ = $is_sim() ? 1000 : 10000000 // put 1000 only for sim, 10M on hardware
    
    edge_detector io_button_edge[5](#RISE(5x{{1}}), #FALL(5x{{0}}), .clk(5x{clk}))
    button_conditioner io_button_cond[5](#CLK_FREQ(5x{{CLK_FREQ}}), .clk(5x{clk}))
         
    multi_seven_seg seg(#DIV(SEVEN_SEG_DIV), .clk(clk), .rst(rst)) 
    dff states[$width(States)](#INIT(States.IDLE), .clk(clk))
    dff a_value[SIZE](.clk(clk), .rst(rst))
    dff b_value[SIZE](.clk(clk), .rst(rst))
    dff current_value[SIZE](.clk(clk), .rst(rst))
    
    bin_to_dec decimal_renderer(#DIGITS(4), #LEADING_ZEROS(1))
    
    always {
        
        // condition the buttons, then take rising edges only
        io_button_cond.in = io_button
        io_button_edge.in = io_button_cond.out
        
        // connect dffs 
        states.d = states.q
        a_value.d = a_value.q
        b_value.d = b_value.q
        current_value.d = current_value.q
        
        // default adder connection
        alu.a = 0
        alu.b = 0
        alu.alufn = 0
        
        case (states.q){
            States.IDLE:
                // this takes precedence
                // if slow clock rising edge, go to UPDATE state
                	if (io_button_edge.out[0]) { //if button 0 is pressed
    			                states.d = States.SET_A_LOW
    		           }
                	else if (io_button_edge.out[2]) { //if button 2 is pressed down
                		     states.d = States.SET_A_HIGH
                	}
                	else if (io_button_edge.out[3]) { //if button 3 is pressed down
                	      states.d = States.SET_B_LOW
                	}	
                	else if (io_button_edge.out[4]) { //if button 4 is pressed down
                	    	 states.d = States.SET_B_HIGH
                	}
                	else if (io_button_edge.out[1]) { //if button 1 is pressed down
                	    	 states.d = States.COMPUTE
                	}  
            
             States.COMPUTE:
                 // add current value by current delta whenever the slowclock edge rises
                 // check if addition cause negative value
            		   alu.a = a_value.q
                 // sign extension of delta
            		   alu.b = b_value.q
                 alu.alufn = io_dip[2][5:0]
                
                 if (io_button_edge.out[1]) { //if button 1 is pressed down
                	    	 states.d = States.IDLE
                	}
                  
             States.SET_A_LOW:

                 a_value.d[15:0] = c{io_dip[1], io_dip[0]}
                 // return to IDLE
                 states.d = States.IDLE
            
            
             States.SET_A_HIGH:

                 a_value.d[31:16] = c{io_dip[1], io_dip[0]}
                 // return to IDLE
                 states.d = States.IDLE
            
             States.SET_B_LOW:
 
                 b_value.d[15:0] = c{io_dip[1], io_dip[0]}
                 // return to IDLE
                 states.d = States.IDLE
            
             States.SET_B_HIGH:

                 b_value.d[31:16] = c{io_dip[1], io_dip[0]}
                 // return to IDLE
		               states.d = States.IDLE

        }
              
        if (alu.z) {
            current_value.d[0] = 1b1
        }
        if (~alu.z) {
            current_value.d[0] = 1b0
        }
        
        if (alu.v) {
            current_value.d[1] = 1b1
            current_value.d[3] = 1b1
        }
        if (~alu.v) {
            current_value.d[1] = 1b0
            current_value.d[3] = 1b0
        }
        
        if (alu.n) {
            current_value.d[2] = 1b1
            current_value.d[5] = 1b1
            current_value.d[6] = 1b1
        }
        if (~alu.n) {
            current_value.d[2] = 1b0
            current_value.d[5] = 1b0
            current_value.d[6] = 1b0
        }
        
        decimal_renderer.value = current_value.q
        seg.values = decimal_renderer.digits
        
        io_segment = ~seg.seg
        io_select = ~seg.sel
        
        io_led[0] = alu.out[7:0]
        io_led[1] = alu.out[15:8]
        io_led[2] = alu.out[23:16]
        led = alu.out[31:24]
        
        
            
    }
}